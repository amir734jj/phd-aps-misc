// Generated by aps2scala version 0.3.6
import basic_implicit._;
object tiny_implicit {
  val tiny_loaded = true;
}
import tiny_implicit._;

trait C_TINY[T_Result] extends C_TYPE[T_Result] {
  type T_Root <: Node;
  val t_Root : C_PHYLUM[T_Root];
  type T_Wood <: Node;
  val t_Wood : C_PHYLUM[T_Wood];
  val p_root : PatternFunction[(T_Root,T_Wood)];
  def v_root : (T_Wood) => T_Root;
  val p_branch : PatternFunction[(T_Wood,T_Wood,T_Wood)];
  def v_branch : (T_Wood,T_Wood) => T_Wood;
  val p_leaf : PatternFunction[(T_Wood,T_Integer)];
  def v_leaf : (T_Integer) => T_Wood;
}

abstract class T_TINY(t : C_TINY[T_TINY]) extends Value(t) { }

class M_TINY(name : String)
  extends I_TYPE[T_TINY](name)
  with C_TINY[T_TINY]
{
  val t_Result : this.type = this;
  abstract class T_Root(t : I_PHYLUM[T_Root]) extends Node(t) {
    override def isRooted : Boolean = true;
  }
  val t_Root = new I_PHYLUM[T_Root]("Root");

  abstract class T_Wood(t : I_PHYLUM[T_Wood]) extends Node(t) {}
  val t_Wood = new I_PHYLUM[T_Wood]("Wood");

  case class c_root(v_w : T_Wood) extends T_Root(t_Root) {
    override def children : List[Node] = List(v_w);
    override def toString() : String = Debug.with_level {
      "root("+ v_w+ ")";
    }
  }
  def u_root(x:Any) : Option[(T_Root,T_Wood)] = x match {
    case x@c_root(v_w) => Some((x,v_w));
    case _ => None };
  val v_root = f_root _;
  def f_root(v_w : T_Wood):T_Root = c_root(v_w).register;
  val p_root = new PatternFunction[(T_Root,T_Wood)](u_root);

  case class c_branch(v_x : T_Wood,v_y : T_Wood) extends T_Wood(t_Wood) {
    override def children : List[Node] = List(v_x,v_y);
    override def toString() : String = Debug.with_level {
      "branch("+ v_x + ","+ v_y+ ")";
    }
  }
  def u_branch(x:Any) : Option[(T_Wood,T_Wood,T_Wood)] = x match {
    case x@c_branch(v_x,v_y) => Some((x,v_x,v_y));
    case _ => None };
  val v_branch = f_branch _;
  def f_branch(v_x : T_Wood, v_y : T_Wood):T_Wood = c_branch(v_x,v_y).register;
  val p_branch = new PatternFunction[(T_Wood,T_Wood,T_Wood)](u_branch);

  case class c_leaf(v_x : T_Integer) extends T_Wood(t_Wood) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "leaf("+ v_x+ ")";
    }
  }
  def u_leaf(x:Any) : Option[(T_Wood,T_Integer)] = x match {
    case x@c_leaf(v_x) => Some((x,v_x));
    case _ => None };
  val v_leaf = f_leaf _;
  def f_leaf(v_x : T_Integer):T_Wood = c_leaf(v_x).register;
  val p_leaf = new PatternFunction[(T_Wood,T_Integer)](u_leaf);

  override def finish() : Unit = {
    super.finish();
  }

}

