// Generated by aps2scala version 0.3.6
import basic_implicit._;
object cycle_implicit {
  val cycle_loaded = true;
  import tiny_implicit._;
  type T_THREE[T_T] = T_T;
}
import cycle_implicit._;

import tiny_implicit._;
trait C_THREE[T_Result, T_T] extends C_TYPE[T_Result] with C_TINY[T_Result] {
  val v_i : (T_Wood) => T_Integer;
  val v_s : (T_Wood) => T_Integer;
}

class M_THREE[T_T](name : String,val t_T : C_TYPE[T_T] with C_TINY[T_T])
  extends Module(name)
    with C_THREE[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Root = t_T.T_Root;
  val t_Root = t_T.t_Root;
  type T_Wood = t_T.T_Wood;
  val t_Wood = t_T.t_Wood;
  val p_root = t_T.p_root;
  val v_root = t_T.v_root;
  val p_branch = t_T.p_branch;
  val v_branch = t_T.v_branch;
  val p_leaf = t_T.p_leaf;
  val v_leaf = t_T.v_leaf;

  val t_Result : this.type = this;
  private class E_i(anchor : T_Wood) extends Evaluation[T_Wood,T_Integer](anchor,anchor.toString()+"."+"i") {
    override def getDefault = 0;
    override def compute : ValueType = c_i(anchor);
  }
  private object a_i extends Attribute[T_Wood,T_Integer](t_Wood,t_Integer,"i") {
    override def createEvaluation(anchor : T_Wood) : Evaluation[T_Wood,T_Integer] = new E_i(anchor);
  }
  val v_i : T_Wood => T_Integer = a_i.get _;

  private class E_s(anchor : T_Wood) extends Evaluation[T_Wood,T_Integer](anchor,anchor.toString()+"."+"s") {
    override def getDefault = 0;
    override def compute : ValueType = c_s(anchor);
  }
  private object a_s extends Attribute[T_Wood,T_Integer](t_Wood,t_Integer,"s") {
    override def createEvaluation(anchor : T_Wood) : Evaluation[T_Wood,T_Integer] = new E_s(anchor);
  }
  val v_s : T_Wood => T_Integer = a_s.get _;

  def c_i(anode : T_Wood) : T_Integer = {
    val anchor = anode.parent;
    if (!(anchor eq null)) {
      val anchorNodes = anchor.myType.nodes;
      if (anchorNodes == t_Result.t_Wood.nodes) anchor match {
        case p_branch(v_b,v_x,v_y) => {
          if (anode eq v_x) return new M__basic_4[ T_Integer](t_Integer).v__op_s(v_s(v_y),v_i(v_b));
          if (anode eq v_y) return new M__basic_4[ T_Integer](t_Integer).v__op_s(v_s(v_x),v_i(v_b));
        }
        case _ => {}
      }
    }
    return 0;
  }
  def c_s(anode : T_Wood) : T_Integer = {
    val anchor = anode;
    anchor match {
      case p_leaf(v_l,v_n) => {
        if (anode eq v_l) return new M__basic_4[ T_Integer](t_Integer).v__op_s(v_i(v_l),v_n);
      }
      case _ => {}
    }
    anchor match {
      case p_branch(v_b,v_x,v_y) => {
        if (anode eq v_b) return 0;
      }
      case _ => {}
    }
    return 0;
  }
  override def finish() : Unit = {
    a_i.finish;
    a_s.finish;
    super.finish();
  }

}

