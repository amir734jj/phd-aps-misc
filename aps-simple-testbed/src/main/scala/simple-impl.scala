// Generated by aps2scala version 0.3.6
import basic_implicit._;
object simple_syn_implicit {
  val simple_syn_loaded = true;
  import simple_implicit._;
  type T_SIMPLE_SYN[T_T] = T_T;
}
import simple_syn_implicit._;

import simple_implicit._;
trait C_SIMPLE_SYN[T_Result, T_T] extends C_TYPE[T_Result] with C_SIMPLE[T_Result] {
  val v_decl_count : (T_Decls) => T_Integer;
}

class M_SIMPLE_SYN[T_T](name : String,val t_T : C_TYPE[T_T] with C_SIMPLE[T_T])
  extends Module(name)
    with C_SIMPLE_SYN[T_T,T_T]
{
  type T_Result = T_T;
  val v_equal = t_T.v_equal;
  val v_string = t_T.v_string;
  val v_assert = t_T.v_assert;
  val v_node_equivalent = t_T.v_node_equivalent;
  type T_Program = t_T.T_Program;
  val t_Program = t_T.t_Program;
  type T_Block = t_T.T_Block;
  val t_Block = t_T.t_Block;
  type T_Decls = t_T.T_Decls;
  val t_Decls = t_T.t_Decls;
  type T_Decl = t_T.T_Decl;
  val t_Decl = t_T.t_Decl;
  type T_Type = t_T.T_Type;
  val t_Type = t_T.t_Type;
  type T_Stmts = t_T.T_Stmts;
  val t_Stmts = t_T.t_Stmts;
  type T_Stmt = t_T.T_Stmt;
  val t_Stmt = t_T.t_Stmt;
  type T_Expr = t_T.T_Expr;
  val t_Expr = t_T.t_Expr;
  val p_program = t_T.p_program;
  val v_program = t_T.v_program;
  val p_block = t_T.p_block;
  val v_block = t_T.v_block;
  val p_no_decls = t_T.p_no_decls;
  val v_no_decls = t_T.v_no_decls;
  val p_xcons_decls = t_T.p_xcons_decls;
  val v_xcons_decls = t_T.v_xcons_decls;
  val p_decl = t_T.p_decl;
  val v_decl = t_T.v_decl;
  val p_integer_type = t_T.p_integer_type;
  val v_integer_type = t_T.v_integer_type;
  val p_string_type = t_T.p_string_type;
  val v_string_type = t_T.v_string_type;
  val p_no_stmts = t_T.p_no_stmts;
  val v_no_stmts = t_T.v_no_stmts;
  val p_xcons_stmts = t_T.p_xcons_stmts;
  val v_xcons_stmts = t_T.v_xcons_stmts;
  val p_block_stmt = t_T.p_block_stmt;
  val v_block_stmt = t_T.v_block_stmt;
  val p_assign_stmt = t_T.p_assign_stmt;
  val v_assign_stmt = t_T.v_assign_stmt;
  val p_intconstant = t_T.p_intconstant;
  val v_intconstant = t_T.v_intconstant;
  val p_strconstant = t_T.p_strconstant;
  val v_strconstant = t_T.v_strconstant;
  val p_variable = t_T.p_variable;
  val v_variable = t_T.v_variable;

  val t_Result : this.type = this;
  private class E_decl_count(anchor : T_Decls) extends Evaluation[T_Decls,T_Integer](anchor,anchor.toString()+"."+"decl_count") {
    override def compute : ValueType = c_decl_count(anchor);
  }
  private object a_decl_count extends Attribute[T_Decls,T_Integer](t_Decls,t_Integer,"decl_count") {
    override def createEvaluation(anchor : T_Decls) : Evaluation[T_Decls,T_Integer] = new E_decl_count(anchor);
  }
  val v_decl_count : T_Decls => T_Integer = a_decl_count.get _;

  def c_decl_count(anode : T_Decls) : T_Integer = {
    val anchor = anode;
    anchor match {
      case p_no_decls(v_ds) => {
        if (anode eq v_ds) return 0;
      }
      case _ => {}
    }
    anchor match {
      case p_xcons_decls(v_ds0,v_ds1,v_d) => {
        if (anode eq v_ds0) return new M__basic_4[ T_Integer](t_Integer).v__op_s(v_decl_count(v_ds1),1);
      }
      case _ => {}
    }
    throw Evaluation.UndefinedAttributeException(anode.toString()+".decl_count");
  }
  override def finish() : Unit = {
    a_decl_count.finish;
    super.finish();
  }

}

