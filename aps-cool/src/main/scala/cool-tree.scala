// Generated by aps2scala version 0.3.6
import basic_implicit._;
object cool_tree_implicit {
  val cool_tree_loaded = true;
import cool_symbol_implicit._;
}
import cool_tree_implicit._;

import cool_symbol_implicit._;
trait C_COOL[T_Result] extends C_TYPE[T_Result] {
  type T_Program <: Node;
  val t_Program : C_PHYLUM[T_Program];
  type T_Class <: Node;
  val t_Class : C_PHYLUM[T_Class];
  type T_Classes <: Node;
  val t_Classes : C_PHYLUM[T_Classes]with C_SEQUENCE[T_Classes,T_Class];
  type T_Feature <: Node;
  val t_Feature : C_PHYLUM[T_Feature];
  type T_Features <: Node;
  val t_Features : C_PHYLUM[T_Features]with C_SEQUENCE[T_Features,T_Feature];
  type T_Formal <: Node;
  val t_Formal : C_PHYLUM[T_Formal];
  type T_Formals <: Node;
  val t_Formals : C_PHYLUM[T_Formals]with C_SEQUENCE[T_Formals,T_Formal];
  type T_Expression <: Node;
  val t_Expression : C_PHYLUM[T_Expression];
  type T_Expressions <: Node;
  val t_Expressions : C_PHYLUM[T_Expressions]with C_SEQUENCE[T_Expressions,T_Expression];
  type T_Case <: Node;
  val t_Case : C_PHYLUM[T_Case];
  type T_Cases <: Node;
  val t_Cases : C_PHYLUM[T_Cases]with C_SEQUENCE[T_Cases,T_Case];
  val p_program : PatternFunction[(T_Program,T_Classes)];
  def v_program : (T_Classes) => T_Program;
  val p_class_decl : PatternFunction[(T_Class,T_Symbol,T_Symbol,T_Features,T_Symbol)];
  def v_class_decl : (T_Symbol,T_Symbol,T_Features,T_Symbol) => T_Class;
  val p_method : PatternFunction[(T_Feature,T_Boolean,T_Symbol,T_Formals,T_Symbol,T_Expression)];
  def v_method : (T_Boolean,T_Symbol,T_Formals,T_Symbol,T_Expression) => T_Feature;
  val p_attr : PatternFunction[(T_Feature,T_Symbol,T_Symbol)];
  def v_attr : (T_Symbol,T_Symbol) => T_Feature;
  val p_formal : PatternFunction[(T_Formal,T_Symbol,T_Symbol)];
  def v_formal : (T_Symbol,T_Symbol) => T_Formal;
  val p_branch : PatternFunction[(T_Case,T_Symbol,T_Symbol,T_Expression)];
  def v_branch : (T_Symbol,T_Symbol,T_Expression) => T_Case;
  val p_assign : PatternFunction[(T_Expression,T_Symbol,T_Expression)];
  def v_assign : (T_Symbol,T_Expression) => T_Expression;
  val p_static_dispatch : PatternFunction[(T_Expression,T_Expression,T_Symbol,T_Symbol,T_Expressions)];
  def v_static_dispatch : (T_Expression,T_Symbol,T_Symbol,T_Expressions) => T_Expression;
  val p_dispatch : PatternFunction[(T_Expression,T_Expression,T_Symbol,T_Expressions)];
  def v_dispatch : (T_Expression,T_Symbol,T_Expressions) => T_Expression;
  val p_cond : PatternFunction[(T_Expression,T_Expression,T_Expression,T_Expression)];
  def v_cond : (T_Expression,T_Expression,T_Expression) => T_Expression;
  val p_loop : PatternFunction[(T_Expression,T_Expression,T_Expression)];
  def v_loop : (T_Expression,T_Expression) => T_Expression;
  val p_typecase : PatternFunction[(T_Expression,T_Expression,T_Cases)];
  def v_typecase : (T_Expression,T_Cases) => T_Expression;
  val p_block : PatternFunction[(T_Expression,T_Expressions)];
  def v_block : (T_Expressions) => T_Expression;
  val p_let : PatternFunction[(T_Expression,T_Symbol,T_Symbol,T_Expression,T_Expression)];
  def v_let : (T_Symbol,T_Symbol,T_Expression,T_Expression) => T_Expression;
  val p_add : PatternFunction[(T_Expression,T_Expression,T_Expression)];
  def v_add : (T_Expression,T_Expression) => T_Expression;
  val p_sub : PatternFunction[(T_Expression,T_Expression,T_Expression)];
  def v_sub : (T_Expression,T_Expression) => T_Expression;
  val p_mul : PatternFunction[(T_Expression,T_Expression,T_Expression)];
  def v_mul : (T_Expression,T_Expression) => T_Expression;
  val p_div : PatternFunction[(T_Expression,T_Expression,T_Expression)];
  def v_div : (T_Expression,T_Expression) => T_Expression;
  val p_neg : PatternFunction[(T_Expression,T_Expression)];
  def v_neg : (T_Expression) => T_Expression;
  val p_lt : PatternFunction[(T_Expression,T_Expression,T_Expression)];
  def v_lt : (T_Expression,T_Expression) => T_Expression;
  val p_leq : PatternFunction[(T_Expression,T_Expression,T_Expression)];
  def v_leq : (T_Expression,T_Expression) => T_Expression;
  val p_comp : PatternFunction[(T_Expression,T_Expression)];
  def v_comp : (T_Expression) => T_Expression;
  val p_int_lit : PatternFunction[(T_Expression,T_Symbol)];
  def v_int_lit : (T_Symbol) => T_Expression;
  val p_bool_lit : PatternFunction[(T_Expression,T_Boolean)];
  def v_bool_lit : (T_Boolean) => T_Expression;
  val p_string_lit : PatternFunction[(T_Expression,T_Symbol)];
  def v_string_lit : (T_Symbol) => T_Expression;
  val p_alloc : PatternFunction[(T_Expression,T_Symbol)];
  def v_alloc : (T_Symbol) => T_Expression;
  val p_nil : PatternFunction[(T_Expression)];
  def v_nil : () => T_Expression;
  val p_unit : PatternFunction[(T_Expression)];
  def v_unit : () => T_Expression;
  val p_no_expr : PatternFunction[(T_Expression)];
  def v_no_expr : () => T_Expression;
  val p_variable : PatternFunction[(T_Expression,T_Symbol)];
  def v_variable : (T_Symbol) => T_Expression;
  val v_inheritablep : (T_Class) => T_Boolean;
}

abstract class T_COOL(t : C_COOL[T_COOL]) extends Value(t) { }

class M_COOL(name : String)
  extends I_TYPE[T_COOL](name)
  with C_COOL[T_COOL]
{
  val t_Result : this.type = this;
  abstract class T_Program(t : I_PHYLUM[T_Program]) extends Node(t) {
    override def isRooted : Boolean = true;
  }
  val t_Program = new I_PHYLUM[T_Program]("Program");

  abstract class T_Class(t : I_PHYLUM[T_Class]) extends Node(t) {}
  val t_Class = new I_PHYLUM[T_Class]("Class");

  val t_Classes = new M_SEQUENCE[T_Class]("Classes",t_Class)

  type T_Classes = /*TI*/T_SEQUENCE[T_Class];
  abstract class T_Feature(t : I_PHYLUM[T_Feature]) extends Node(t) {}
  val t_Feature = new I_PHYLUM[T_Feature]("Feature");

  val t_Features = new M_SEQUENCE[T_Feature]("Features",t_Feature)

  type T_Features = /*TI*/T_SEQUENCE[T_Feature];
  abstract class T_Formal(t : I_PHYLUM[T_Formal]) extends Node(t) {}
  val t_Formal = new I_PHYLUM[T_Formal]("Formal");

  val t_Formals = new M_SEQUENCE[T_Formal]("Formals",t_Formal)

  type T_Formals = /*TI*/T_SEQUENCE[T_Formal];
  abstract class T_Expression(t : I_PHYLUM[T_Expression]) extends Node(t) {}
  val t_Expression = new I_PHYLUM[T_Expression]("Expression");

  val t_Expressions = new M_SEQUENCE[T_Expression]("Expressions",t_Expression)

  type T_Expressions = /*TI*/T_SEQUENCE[T_Expression];
  abstract class T_Case(t : I_PHYLUM[T_Case]) extends Node(t) {}
  val t_Case = new I_PHYLUM[T_Case]("Case");

  val t_Cases = new M_SEQUENCE[T_Case]("Cases",t_Case)

  type T_Cases = /*TI*/T_SEQUENCE[T_Case];
  case class c_program(v_classes : T_Classes) extends T_Program(t_Program) {
    override def children : List[Node] = List(v_classes);
    override def toString() : String = Debug.with_level {
      "program("+ v_classes+ ")";
    }
  }
  def u_program(x:Any) : Option[(T_Program,T_Classes)] = x match {
    case x@c_program(v_classes) => Some((x,v_classes));
    case _ => None };
  val v_program = f_program _;
  def f_program(v_classes : T_Classes):T_Program = c_program(v_classes).register;
  val p_program = new PatternFunction[(T_Program,T_Classes)](u_program);

  case class c_class_decl(v_name : T_Symbol,v_parent : T_Symbol,v_features : T_Features,v_filename : T_Symbol) extends T_Class(t_Class) {
    override def children : List[Node] = List(v_features);
    override def toString() : String = Debug.with_level {
      "class_decl("+ v_name + ","+ v_parent + ","+ v_features + ","+ v_filename+ ")";
    }
  }
  def u_class_decl(x:Any) : Option[(T_Class,T_Symbol,T_Symbol,T_Features,T_Symbol)] = x match {
    case x@c_class_decl(v_name,v_parent,v_features,v_filename) => Some((x,v_name,v_parent,v_features,v_filename));
    case _ => None };
  val v_class_decl = f_class_decl _;
  def f_class_decl(v_name : T_Symbol, v_parent : T_Symbol, v_features : T_Features, v_filename : T_Symbol):T_Class = c_class_decl(v_name,v_parent,v_features,v_filename).register;
  val p_class_decl = new PatternFunction[(T_Class,T_Symbol,T_Symbol,T_Features,T_Symbol)](u_class_decl);

  case class c_method(v_overridep : T_Boolean,v_name : T_Symbol,v_formals : T_Formals,v_return_type : T_Symbol,v_expr : T_Expression) extends T_Feature(t_Feature) {
    override def children : List[Node] = List(v_formals,v_expr);
    override def toString() : String = Debug.with_level {
      "method("+ v_overridep + ","+ v_name + ","+ v_formals + ","+ v_return_type + ","+ v_expr+ ")";
    }
  }
  def u_method(x:Any) : Option[(T_Feature,T_Boolean,T_Symbol,T_Formals,T_Symbol,T_Expression)] = x match {
    case x@c_method(v_overridep,v_name,v_formals,v_return_type,v_expr) => Some((x,v_overridep,v_name,v_formals,v_return_type,v_expr));
    case _ => None };
  val v_method = f_method _;
  def f_method(v_overridep : T_Boolean, v_name : T_Symbol, v_formals : T_Formals, v_return_type : T_Symbol, v_expr : T_Expression):T_Feature = c_method(v_overridep,v_name,v_formals,v_return_type,v_expr).register;
  val p_method = new PatternFunction[(T_Feature,T_Boolean,T_Symbol,T_Formals,T_Symbol,T_Expression)](u_method);

  case class c_attr(v_name : T_Symbol,v_of_type : T_Symbol) extends T_Feature(t_Feature) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "attr("+ v_name + ","+ v_of_type+ ")";
    }
  }
  def u_attr(x:Any) : Option[(T_Feature,T_Symbol,T_Symbol)] = x match {
    case x@c_attr(v_name,v_of_type) => Some((x,v_name,v_of_type));
    case _ => None };
  val v_attr = f_attr _;
  def f_attr(v_name : T_Symbol, v_of_type : T_Symbol):T_Feature = c_attr(v_name,v_of_type).register;
  val p_attr = new PatternFunction[(T_Feature,T_Symbol,T_Symbol)](u_attr);

  case class c_formal(v_name : T_Symbol,v_of_type : T_Symbol) extends T_Formal(t_Formal) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "formal("+ v_name + ","+ v_of_type+ ")";
    }
  }
  def u_formal(x:Any) : Option[(T_Formal,T_Symbol,T_Symbol)] = x match {
    case x@c_formal(v_name,v_of_type) => Some((x,v_name,v_of_type));
    case _ => None };
  val v_formal = f_formal _;
  def f_formal(v_name : T_Symbol, v_of_type : T_Symbol):T_Formal = c_formal(v_name,v_of_type).register;
  val p_formal = new PatternFunction[(T_Formal,T_Symbol,T_Symbol)](u_formal);

  case class c_branch(v_name : T_Symbol,v_local_type : T_Symbol,v_expr : T_Expression) extends T_Case(t_Case) {
    override def children : List[Node] = List(v_expr);
    override def toString() : String = Debug.with_level {
      "branch("+ v_name + ","+ v_local_type + ","+ v_expr+ ")";
    }
  }
  def u_branch(x:Any) : Option[(T_Case,T_Symbol,T_Symbol,T_Expression)] = x match {
    case x@c_branch(v_name,v_local_type,v_expr) => Some((x,v_name,v_local_type,v_expr));
    case _ => None };
  val v_branch = f_branch _;
  def f_branch(v_name : T_Symbol, v_local_type : T_Symbol, v_expr : T_Expression):T_Case = c_branch(v_name,v_local_type,v_expr).register;
  val p_branch = new PatternFunction[(T_Case,T_Symbol,T_Symbol,T_Expression)](u_branch);

  case class c_assign(v_name : T_Symbol,v_expr : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_expr);
    override def toString() : String = Debug.with_level {
      "assign("+ v_name + ","+ v_expr+ ")";
    }
  }
  def u_assign(x:Any) : Option[(T_Expression,T_Symbol,T_Expression)] = x match {
    case x@c_assign(v_name,v_expr) => Some((x,v_name,v_expr));
    case _ => None };
  val v_assign = f_assign _;
  def f_assign(v_name : T_Symbol, v_expr : T_Expression):T_Expression = c_assign(v_name,v_expr).register;
  val p_assign = new PatternFunction[(T_Expression,T_Symbol,T_Expression)](u_assign);

  case class c_static_dispatch(v_expr : T_Expression,v_type_name : T_Symbol,v_name : T_Symbol,v_actuals : T_Expressions) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_expr,v_actuals);
    override def toString() : String = Debug.with_level {
      "static_dispatch("+ v_expr + ","+ v_type_name + ","+ v_name + ","+ v_actuals+ ")";
    }
  }
  def u_static_dispatch(x:Any) : Option[(T_Expression,T_Expression,T_Symbol,T_Symbol,T_Expressions)] = x match {
    case x@c_static_dispatch(v_expr,v_type_name,v_name,v_actuals) => Some((x,v_expr,v_type_name,v_name,v_actuals));
    case _ => None };
  val v_static_dispatch = f_static_dispatch _;
  def f_static_dispatch(v_expr : T_Expression, v_type_name : T_Symbol, v_name : T_Symbol, v_actuals : T_Expressions):T_Expression = c_static_dispatch(v_expr,v_type_name,v_name,v_actuals).register;
  val p_static_dispatch = new PatternFunction[(T_Expression,T_Expression,T_Symbol,T_Symbol,T_Expressions)](u_static_dispatch);

  case class c_dispatch(v_expr : T_Expression,v_name : T_Symbol,v_actuals : T_Expressions) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_expr,v_actuals);
    override def toString() : String = Debug.with_level {
      "dispatch("+ v_expr + ","+ v_name + ","+ v_actuals+ ")";
    }
  }
  def u_dispatch(x:Any) : Option[(T_Expression,T_Expression,T_Symbol,T_Expressions)] = x match {
    case x@c_dispatch(v_expr,v_name,v_actuals) => Some((x,v_expr,v_name,v_actuals));
    case _ => None };
  val v_dispatch = f_dispatch _;
  def f_dispatch(v_expr : T_Expression, v_name : T_Symbol, v_actuals : T_Expressions):T_Expression = c_dispatch(v_expr,v_name,v_actuals).register;
  val p_dispatch = new PatternFunction[(T_Expression,T_Expression,T_Symbol,T_Expressions)](u_dispatch);

  case class c_cond(v_pred : T_Expression,v_then_exp : T_Expression,v_else_exp : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_pred,v_then_exp,v_else_exp);
    override def toString() : String = Debug.with_level {
      "cond("+ v_pred + ","+ v_then_exp + ","+ v_else_exp+ ")";
    }
  }
  def u_cond(x:Any) : Option[(T_Expression,T_Expression,T_Expression,T_Expression)] = x match {
    case x@c_cond(v_pred,v_then_exp,v_else_exp) => Some((x,v_pred,v_then_exp,v_else_exp));
    case _ => None };
  val v_cond = f_cond _;
  def f_cond(v_pred : T_Expression, v_then_exp : T_Expression, v_else_exp : T_Expression):T_Expression = c_cond(v_pred,v_then_exp,v_else_exp).register;
  val p_cond = new PatternFunction[(T_Expression,T_Expression,T_Expression,T_Expression)](u_cond);

  case class c_loop(v_pred : T_Expression,v_body : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_pred,v_body);
    override def toString() : String = Debug.with_level {
      "loop("+ v_pred + ","+ v_body+ ")";
    }
  }
  def u_loop(x:Any) : Option[(T_Expression,T_Expression,T_Expression)] = x match {
    case x@c_loop(v_pred,v_body) => Some((x,v_pred,v_body));
    case _ => None };
  val v_loop = f_loop _;
  def f_loop(v_pred : T_Expression, v_body : T_Expression):T_Expression = c_loop(v_pred,v_body).register;
  val p_loop = new PatternFunction[(T_Expression,T_Expression,T_Expression)](u_loop);

  case class c_typecase(v_expr : T_Expression,v_cases : T_Cases) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_expr,v_cases);
    override def toString() : String = Debug.with_level {
      "typecase("+ v_expr + ","+ v_cases+ ")";
    }
  }
  def u_typecase(x:Any) : Option[(T_Expression,T_Expression,T_Cases)] = x match {
    case x@c_typecase(v_expr,v_cases) => Some((x,v_expr,v_cases));
    case _ => None };
  val v_typecase = f_typecase _;
  def f_typecase(v_expr : T_Expression, v_cases : T_Cases):T_Expression = c_typecase(v_expr,v_cases).register;
  val p_typecase = new PatternFunction[(T_Expression,T_Expression,T_Cases)](u_typecase);

  case class c_block(v_body : T_Expressions) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_body);
    override def toString() : String = Debug.with_level {
      "block("+ v_body+ ")";
    }
  }
  def u_block(x:Any) : Option[(T_Expression,T_Expressions)] = x match {
    case x@c_block(v_body) => Some((x,v_body));
    case _ => None };
  val v_block = f_block _;
  def f_block(v_body : T_Expressions):T_Expression = c_block(v_body).register;
  val p_block = new PatternFunction[(T_Expression,T_Expressions)](u_block);

  case class c_let(v_identifier : T_Symbol,v_local_type : T_Symbol,v_init : T_Expression,v_body : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_init,v_body);
    override def toString() : String = Debug.with_level {
      "let("+ v_identifier + ","+ v_local_type + ","+ v_init + ","+ v_body+ ")";
    }
  }
  def u_let(x:Any) : Option[(T_Expression,T_Symbol,T_Symbol,T_Expression,T_Expression)] = x match {
    case x@c_let(v_identifier,v_local_type,v_init,v_body) => Some((x,v_identifier,v_local_type,v_init,v_body));
    case _ => None };
  val v_let = f_let _;
  def f_let(v_identifier : T_Symbol, v_local_type : T_Symbol, v_init : T_Expression, v_body : T_Expression):T_Expression = c_let(v_identifier,v_local_type,v_init,v_body).register;
  val p_let = new PatternFunction[(T_Expression,T_Symbol,T_Symbol,T_Expression,T_Expression)](u_let);

  case class c_add(v_e1 : T_Expression,v_e2 : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_e1,v_e2);
    override def toString() : String = Debug.with_level {
      "add("+ v_e1 + ","+ v_e2+ ")";
    }
  }
  def u_add(x:Any) : Option[(T_Expression,T_Expression,T_Expression)] = x match {
    case x@c_add(v_e1,v_e2) => Some((x,v_e1,v_e2));
    case _ => None };
  val v_add = f_add _;
  def f_add(v_e1 : T_Expression, v_e2 : T_Expression):T_Expression = c_add(v_e1,v_e2).register;
  val p_add = new PatternFunction[(T_Expression,T_Expression,T_Expression)](u_add);

  case class c_sub(v_e1 : T_Expression,v_e2 : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_e1,v_e2);
    override def toString() : String = Debug.with_level {
      "sub("+ v_e1 + ","+ v_e2+ ")";
    }
  }
  def u_sub(x:Any) : Option[(T_Expression,T_Expression,T_Expression)] = x match {
    case x@c_sub(v_e1,v_e2) => Some((x,v_e1,v_e2));
    case _ => None };
  val v_sub = f_sub _;
  def f_sub(v_e1 : T_Expression, v_e2 : T_Expression):T_Expression = c_sub(v_e1,v_e2).register;
  val p_sub = new PatternFunction[(T_Expression,T_Expression,T_Expression)](u_sub);

  case class c_mul(v_e1 : T_Expression,v_e2 : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_e1,v_e2);
    override def toString() : String = Debug.with_level {
      "mul("+ v_e1 + ","+ v_e2+ ")";
    }
  }
  def u_mul(x:Any) : Option[(T_Expression,T_Expression,T_Expression)] = x match {
    case x@c_mul(v_e1,v_e2) => Some((x,v_e1,v_e2));
    case _ => None };
  val v_mul = f_mul _;
  def f_mul(v_e1 : T_Expression, v_e2 : T_Expression):T_Expression = c_mul(v_e1,v_e2).register;
  val p_mul = new PatternFunction[(T_Expression,T_Expression,T_Expression)](u_mul);

  case class c_div(v_e1 : T_Expression,v_e2 : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_e1,v_e2);
    override def toString() : String = Debug.with_level {
      "div("+ v_e1 + ","+ v_e2+ ")";
    }
  }
  def u_div(x:Any) : Option[(T_Expression,T_Expression,T_Expression)] = x match {
    case x@c_div(v_e1,v_e2) => Some((x,v_e1,v_e2));
    case _ => None };
  val v_div = f_div _;
  def f_div(v_e1 : T_Expression, v_e2 : T_Expression):T_Expression = c_div(v_e1,v_e2).register;
  val p_div = new PatternFunction[(T_Expression,T_Expression,T_Expression)](u_div);

  case class c_neg(v_e1 : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_e1);
    override def toString() : String = Debug.with_level {
      "neg("+ v_e1+ ")";
    }
  }
  def u_neg(x:Any) : Option[(T_Expression,T_Expression)] = x match {
    case x@c_neg(v_e1) => Some((x,v_e1));
    case _ => None };
  val v_neg = f_neg _;
  def f_neg(v_e1 : T_Expression):T_Expression = c_neg(v_e1).register;
  val p_neg = new PatternFunction[(T_Expression,T_Expression)](u_neg);

  case class c_lt(v_e1 : T_Expression,v_e2 : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_e1,v_e2);
    override def toString() : String = Debug.with_level {
      "lt("+ v_e1 + ","+ v_e2+ ")";
    }
  }
  def u_lt(x:Any) : Option[(T_Expression,T_Expression,T_Expression)] = x match {
    case x@c_lt(v_e1,v_e2) => Some((x,v_e1,v_e2));
    case _ => None };
  val v_lt = f_lt _;
  def f_lt(v_e1 : T_Expression, v_e2 : T_Expression):T_Expression = c_lt(v_e1,v_e2).register;
  val p_lt = new PatternFunction[(T_Expression,T_Expression,T_Expression)](u_lt);

  case class c_leq(v_e1 : T_Expression,v_e2 : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_e1,v_e2);
    override def toString() : String = Debug.with_level {
      "leq("+ v_e1 + ","+ v_e2+ ")";
    }
  }
  def u_leq(x:Any) : Option[(T_Expression,T_Expression,T_Expression)] = x match {
    case x@c_leq(v_e1,v_e2) => Some((x,v_e1,v_e2));
    case _ => None };
  val v_leq = f_leq _;
  def f_leq(v_e1 : T_Expression, v_e2 : T_Expression):T_Expression = c_leq(v_e1,v_e2).register;
  val p_leq = new PatternFunction[(T_Expression,T_Expression,T_Expression)](u_leq);

  case class c_comp(v_e1 : T_Expression) extends T_Expression(t_Expression) {
    override def children : List[Node] = List(v_e1);
    override def toString() : String = Debug.with_level {
      "comp("+ v_e1+ ")";
    }
  }
  def u_comp(x:Any) : Option[(T_Expression,T_Expression)] = x match {
    case x@c_comp(v_e1) => Some((x,v_e1));
    case _ => None };
  val v_comp = f_comp _;
  def f_comp(v_e1 : T_Expression):T_Expression = c_comp(v_e1).register;
  val p_comp = new PatternFunction[(T_Expression,T_Expression)](u_comp);

  case class c_int_lit(v_token : T_Symbol) extends T_Expression(t_Expression) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "int_lit("+ v_token+ ")";
    }
  }
  def u_int_lit(x:Any) : Option[(T_Expression,T_Symbol)] = x match {
    case x@c_int_lit(v_token) => Some((x,v_token));
    case _ => None };
  val v_int_lit = f_int_lit _;
  def f_int_lit(v_token : T_Symbol):T_Expression = c_int_lit(v_token).register;
  val p_int_lit = new PatternFunction[(T_Expression,T_Symbol)](u_int_lit);

  case class c_bool_lit(v_val : T_Boolean) extends T_Expression(t_Expression) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "bool_lit("+ v_val+ ")";
    }
  }
  def u_bool_lit(x:Any) : Option[(T_Expression,T_Boolean)] = x match {
    case x@c_bool_lit(v_val) => Some((x,v_val));
    case _ => None };
  val v_bool_lit = f_bool_lit _;
  def f_bool_lit(v_val : T_Boolean):T_Expression = c_bool_lit(v_val).register;
  val p_bool_lit = new PatternFunction[(T_Expression,T_Boolean)](u_bool_lit);

  case class c_string_lit(v_token : T_Symbol) extends T_Expression(t_Expression) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "string_lit("+ v_token+ ")";
    }
  }
  def u_string_lit(x:Any) : Option[(T_Expression,T_Symbol)] = x match {
    case x@c_string_lit(v_token) => Some((x,v_token));
    case _ => None };
  val v_string_lit = f_string_lit _;
  def f_string_lit(v_token : T_Symbol):T_Expression = c_string_lit(v_token).register;
  val p_string_lit = new PatternFunction[(T_Expression,T_Symbol)](u_string_lit);

  case class c_alloc(v_type_name : T_Symbol) extends T_Expression(t_Expression) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "alloc("+ v_type_name+ ")";
    }
  }
  def u_alloc(x:Any) : Option[(T_Expression,T_Symbol)] = x match {
    case x@c_alloc(v_type_name) => Some((x,v_type_name));
    case _ => None };
  val v_alloc = f_alloc _;
  def f_alloc(v_type_name : T_Symbol):T_Expression = c_alloc(v_type_name).register;
  val p_alloc = new PatternFunction[(T_Expression,T_Symbol)](u_alloc);

  case class c_nil() extends T_Expression(t_Expression) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "nil("+ ")";
    }
  }
  def u_nil(x:Any) : Option[(T_Expression)] = x match {
    case x@c_nil() => Some(x);
    case _ => None };
  val v_nil = f_nil _;
  def f_nil():T_Expression = c_nil().register;
  val p_nil = new PatternFunction[(T_Expression)](u_nil);

  case class c_unit() extends T_Expression(t_Expression) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "unit("+ ")";
    }
  }
  def u_unit(x:Any) : Option[(T_Expression)] = x match {
    case x@c_unit() => Some(x);
    case _ => None };
  val v_unit = f_unit _;
  def f_unit():T_Expression = c_unit().register;
  val p_unit = new PatternFunction[(T_Expression)](u_unit);

  case class c_no_expr() extends T_Expression(t_Expression) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "no_expr("+ ")";
    }
  }
  def u_no_expr(x:Any) : Option[(T_Expression)] = x match {
    case x@c_no_expr() => Some(x);
    case _ => None };
  val v_no_expr = f_no_expr _;
  def f_no_expr():T_Expression = c_no_expr().register;
  val p_no_expr = new PatternFunction[(T_Expression)](u_no_expr);

  case class c_variable(v_name : T_Symbol) extends T_Expression(t_Expression) {
    override def children : List[Node] = List();
    override def toString() : String = Debug.with_level {
      "variable("+ v_name+ ")";
    }
  }
  def u_variable(x:Any) : Option[(T_Expression,T_Symbol)] = x match {
    case x@c_variable(v_name) => Some((x,v_name));
    case _ => None };
  val v_variable = f_variable _;
  def f_variable(v_name : T_Symbol):T_Expression = c_variable(v_name).register;
  val p_variable = new PatternFunction[(T_Expression,T_Symbol)](u_variable);

  private class E_inheritablep(anchor : T_Class) extends Evaluation[T_Class,T_Boolean](anchor,anchor.toString()+"."+"inheritablep") {
    override def getDefault = v_true;
    override def compute : ValueType = c_inheritablep(anchor);
  }
  private object a_inheritablep extends Attribute[T_Class,T_Boolean](t_Class,t_Boolean,"inheritablep") {
    override def createEvaluation(anchor : T_Class) : Evaluation[T_Class,T_Boolean] = new E_inheritablep(anchor);
  }
  val v_inheritablep : T_Class => T_Boolean = a_inheritablep.get _;
  def s_inheritablep(node:T_Class, value:T_Boolean) = a_inheritablep.assign(node,value);

  def c_inheritablep(anode : T_Class) : T_Boolean = {
    val anchor = anode;
    return v_true;
  }
  override def finish() : Unit = {
    a_inheritablep.finish;
    super.finish();
  }

}

