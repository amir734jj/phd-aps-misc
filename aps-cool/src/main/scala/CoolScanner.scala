import cool_implicit._
/* The following code was generated by JFlex 1.5.0-SNAPSHOT (+scala) on 8/11/22, 3:28 PM */

/* Cool.flex language lexer specification */


/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.5.0-SNAPSHOT (+scala)
 * on 8/11/22, 3:28 PM from the specification file
 * <tt>Cool.lex</tt>
 */
class CoolScanner(private var zzReader : java.io.Reader) extends Iterator[CoolTokens.YYToken] {
  def this(in : java.io.InputStream) = this(new java.io.InputStreamReader(in));

  /** This character denotes the end of file */
  val YYEOF : Int = -1;

  /** initial size of the lookahead buffer */
   private val ZZ_BUFFERSIZE:Int =  16384;

  /** lexical states */
  val YYINITIAL:Int = 0;
  val STRING:Int = 2;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
   private val ZZ_LEXSTATE:Array[Int] = Array(
     0,  0,  1, 1
  );

  /** 
   * Translates characters to character classes
   */
   private val ZZ_CMAP_PACKED:String = 
    "\11\0\1\2\1\1\2\0\1\2\22\0\1\2\1\6\1\7\5\0"+
    "\2\6\1\12\4\6\1\11\1\16\11\10\2\6\1\13\1\14\1\15"+
    "\2\0\22\3\1\44\7\3\1\0\1\51\2\0\1\4\1\0\1\20"+
    "\1\42\1\17\1\24\1\22\1\25\1\50\1\33\1\31\1\46\1\47"+
    "\1\23\1\32\1\30\1\37\1\41\1\5\1\40\1\21\1\27\1\36"+
    "\1\34\1\35\1\26\1\43\1\45\1\6\1\0\1\6\uff82\0";

  /** 
   * Translates characters to character classes
   */
   private val ZZ_CMAP:Array[Char] = zzUnpackCMap(ZZ_CMAP_PACKED);

  /** 
   * Translates DFA states to action switch labels.
   */

   private val ZZ_ACTION_PACKED_0:String = 
    "\2\0\1\1\2\2\1\3\1\1\1\4\1\5\1\6"+
    "\1\7\3\5\1\10\21\4\1\11\1\12\1\13\1\14"+
    "\2\15\1\0\1\2\1\16\1\17\1\20\1\21\1\22"+
    "\11\4\1\23\11\4\1\24\13\4\1\25\1\26\1\27"+
    "\1\30\1\31\1\32\1\33\1\34\1\35\1\36\1\16"+
    "\11\4\1\37\2\4\1\40\4\4\1\41\2\4\1\42"+
    "\3\4\1\43\1\44\12\4\1\36\1\45\5\4\1\46"+
    "\1\4\1\47\3\4\1\50\2\4\1\51\1\52\1\4"+
    "\1\53\3\4\1\54\11\4\1\36\1\55\1\56\2\4"+
    "\1\57\1\4\1\60\1\61\1\4\1\62\1\63\3\4"+
    "\1\64\1\65\7\4\1\66\1\67\1\4\1\70\3\4"+
    "\1\71\1\4\1\72\1\4\1\73\1\4\1\74\4\4"+
    "\1\75\1\76\1\77\3\4\1\100\1\101\1\4\1\102"+
    "\1\103\1\104\1\105\1\4\1\106";

  private def zzUnpackAction() : Array[Int] =  {
    val result:Array[Int] = new Array[Int](213);
    var offset:Int = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private def zzUnpackAction(packed:String,offset:Int,result:Array[Int]) : Int =  {
    var i:Int = 0;       /* index in packed string  */
    var j:Int = offset;  /* index in unpacked array */
    val l:Int = packed.length();
    while (i < l) {
      var count:Int = packed.charAt(i); i+= 1;
      var value:Int = packed.charAt(i); i+= 1;
      do { result(j) = value; j+=1; count -= 1; } while (count > 0);
    }
    return j;
  }
   private val ZZ_ACTION:Array[Int] = zzUnpackAction();


  /** 
   * Translates a state to a row index in the transition table
   */

   private val ZZ_ROWMAP_PACKED_0:String = 
    "\0\0\0\52\0\124\0\176\0\250\0\322\0\374\0\u0126"+
    "\0\176\0\u0150\0\u017a\0\u01a4\0\u01ce\0\u01f8\0\u0222\0\u024c"+
    "\0\u0276\0\u02a0\0\u02ca\0\u02f4\0\u031e\0\u0348\0\u0372\0\u039c"+
    "\0\u03c6\0\u03f0\0\u041a\0\u0444\0\u046e\0\u0498\0\u04c2\0\u04ec"+
    "\0\u0516\0\176\0\176\0\u0540\0\u056a\0\374\0\u0594\0\u05be"+
    "\0\u05e8\0\176\0\176\0\176\0\u0222\0\u0612\0\u063c\0\u0666"+
    "\0\u0690\0\u06ba\0\u06e4\0\u070e\0\u0738\0\u0762\0\u0126\0\u078c"+
    "\0\u07b6\0\u07e0\0\u080a\0\u0834\0\u085e\0\u0888\0\u08b2\0\u08dc"+
    "\0\u0126\0\u0906\0\u0930\0\u095a\0\u0984\0\u09ae\0\u09d8\0\u0a02"+
    "\0\u0a2c\0\u0a56\0\u0a80\0\u0aaa\0\176\0\176\0\176\0\176"+
    "\0\176\0\176\0\176\0\176\0\176\0\u0ad4\0\u0afe\0\u0b28"+
    "\0\u0b52\0\u0b7c\0\u0ba6\0\u0bd0\0\u0bfa\0\u0c24\0\u0c4e\0\u0c78"+
    "\0\u0126\0\u0ca2\0\u0ccc\0\u0cf6\0\u0d20\0\u0d4a\0\u0d74\0\u0d9e"+
    "\0\u0126\0\u0dc8\0\u0df2\0\u0126\0\u0e1c\0\u0e46\0\u0e70\0\u0126"+
    "\0\u0126\0\u0e9a\0\u0ec4\0\u0eee\0\u0f18\0\u0f42\0\u0f6c\0\u0f96"+
    "\0\u0fc0\0\u0fea\0\u1014\0\u103e\0\u0126\0\u1068\0\u1092\0\u10bc"+
    "\0\u10e6\0\u1110\0\u0126\0\u113a\0\u0126\0\u1164\0\u118e\0\u11b8"+
    "\0\u0126\0\u11e2\0\u120c\0\u0126\0\u0126\0\u1236\0\u0126\0\u1260"+
    "\0\u128a\0\u12b4\0\u0126\0\u12de\0\u1308\0\u1332\0\u135c\0\u1386"+
    "\0\u13b0\0\u13da\0\u1404\0\u142e\0\u1458\0\u0126\0\u0126\0\u1482"+
    "\0\u14ac\0\u0126\0\u14d6\0\u0126\0\u1500\0\u152a\0\u0126\0\u0126"+
    "\0\u1554\0\u157e\0\u15a8\0\u0126\0\u0126\0\u15d2\0\u15fc\0\u1626"+
    "\0\u1650\0\u167a\0\u16a4\0\u16ce\0\u0126\0\176\0\u16f8\0\u0126"+
    "\0\u1722\0\u174c\0\u1776\0\u0126\0\u17a0\0\u0126\0\u17ca\0\u0126"+
    "\0\u17f4\0\u0126\0\u181e\0\u1848\0\u1872\0\u189c\0\u0126\0\u0126"+
    "\0\u0126\0\u18c6\0\u18f0\0\u191a\0\u0126\0\u0126\0\u1944\0\u0126"+
    "\0\u0126\0\u0126\0\u0126\0\u196e\0\u0126";

  private def zzUnpackRowMap() : Array[Int] =  {
    val result:Array[Int] = new Array[Int](213);
    var offset:Int = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private def zzUnpackRowMap(packed:String,offset:Int,result:Array[Int]) : Int =  {
    var i:Int = 0;       /* index in packed string  */
    var j:Int = offset;  /* index in unpacked array */
    val l:Int = packed.length();
    while (i < l) {
      val high:Int = packed.charAt(i) << 16; i+= 1;
      result(j) = high | packed.charAt(i); i+= 1; j += 1;
    }
    return j;
  }
   private val ZZ_ROWMAP:Array[Int] = zzUnpackRowMap();

  /** 
   * The transition table of the DFA
   */

   private val ZZ_TRANS_PACKED_0:String = 
    "\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12"+
    "\1\13\1\14\1\11\1\15\1\16\1\3\1\17\1\20"+
    "\1\21\1\22\1\23\1\24\1\25\1\26\1\10\1\27"+
    "\1\30\1\31\1\32\1\10\1\33\1\34\1\10\1\35"+
    "\1\36\1\37\1\10\1\40\1\6\4\10\1\3\1\41"+
    "\1\42\5\41\1\43\41\41\1\44\1\3\3\0\1\3"+
    "\10\0\1\3\33\0\1\3\54\0\1\5\52\0\3\6"+
    "\2\0\1\6\5\0\33\6\1\0\1\3\2\0\1\45"+
    "\1\46\1\45\2\0\1\45\4\0\1\3\33\45\1\3"+
    "\3\0\3\10\2\0\1\10\5\0\33\10\10\0\1\47"+
    "\52\0\1\13\5\0\1\13\44\0\1\50\1\51\53\0"+
    "\1\52\51\0\1\53\1\54\44\0\1\55\5\0\1\55"+
    "\36\0\3\10\2\0\1\10\5\0\2\10\1\56\2\10"+
    "\1\57\25\10\4\0\3\10\2\0\1\10\5\0\24\10"+
    "\1\60\6\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\61\13\10\1\62\12\10\4\0\3\10\2\0\1\10"+
    "\5\0\5\10\1\63\2\10\1\64\22\10\4\0\3\10"+
    "\2\0\1\10\5\0\2\10\1\65\30\10\4\0\3\10"+
    "\2\0\1\10\5\0\4\10\1\66\14\10\1\67\11\10"+
    "\4\0\3\10\2\0\1\10\5\0\2\10\1\70\10\10"+
    "\1\71\5\10\1\72\11\10\4\0\3\10\2\0\1\10"+
    "\5\0\15\10\1\73\4\10\1\74\2\10\1\75\5\10"+
    "\4\0\3\10\2\0\1\10\5\0\2\10\1\76\1\10"+
    "\1\77\13\10\1\100\12\10\4\0\3\10\2\0\1\10"+
    "\5\0\7\10\1\101\4\10\1\102\16\10\4\0\3\10"+
    "\2\0\1\10\5\0\2\10\1\103\30\10\4\0\3\10"+
    "\2\0\1\10\5\0\2\10\1\104\30\10\4\0\3\10"+
    "\2\0\1\10\5\0\13\10\1\105\1\10\1\106\15\10"+
    "\4\0\3\10\2\0\1\10\5\0\16\10\1\107\5\10"+
    "\1\110\6\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\111\26\10\4\0\3\10\2\0\1\10\5\0\2\10"+
    "\1\112\17\10\1\113\10\10\4\0\3\10\2\0\1\10"+
    "\5\0\13\10\1\114\17\10\1\0\1\41\1\0\5\41"+
    "\1\0\41\41\1\0\1\115\1\116\5\115\1\117\15\115"+
    "\1\120\1\115\1\121\1\122\7\115\1\123\1\115\1\124"+
    "\6\115\1\125\3\0\3\45\2\0\1\45\5\0\33\45"+
    "\10\0\1\126\42\0\1\50\1\0\50\50\12\51\1\127"+
    "\37\51\3\0\3\10\2\0\1\10\5\0\3\10\1\130"+
    "\5\10\1\131\21\10\4\0\3\10\2\0\1\10\5\0"+
    "\2\10\1\132\30\10\4\0\3\10\2\0\1\10\5\0"+
    "\3\10\1\133\27\10\4\0\3\10\2\0\1\10\5\0"+
    "\2\10\1\134\30\10\4\0\3\10\2\0\1\10\5\0"+
    "\23\10\1\135\7\10\4\0\3\10\2\0\1\10\5\0"+
    "\3\10\1\136\27\10\4\0\3\10\2\0\1\10\5\0"+
    "\11\10\1\137\21\10\4\0\3\10\2\0\1\10\5\0"+
    "\27\10\1\140\3\10\4\0\3\10\2\0\1\10\5\0"+
    "\7\10\1\141\23\10\4\0\3\10\2\0\1\10\5\0"+
    "\5\10\1\142\25\10\4\0\3\10\2\0\1\10\5\0"+
    "\12\10\1\143\20\10\4\0\3\10\2\0\1\10\5\0"+
    "\22\10\1\144\10\10\4\0\3\10\2\0\1\10\5\0"+
    "\13\10\1\145\6\10\1\146\10\10\4\0\3\10\2\0"+
    "\1\10\5\0\2\10\1\147\15\10\1\150\4\10\1\151"+
    "\5\10\4\0\3\10\2\0\1\10\5\0\23\10\1\152"+
    "\7\10\4\0\3\10\2\0\1\10\5\0\11\10\1\153"+
    "\21\10\4\0\3\10\2\0\1\10\5\0\17\10\1\154"+
    "\13\10\4\0\3\10\2\0";

   private val ZZ_TRANS_PACKED_1:String = 
    "\1\10\5\0\5\10\1\155\25\10\4\0\3\10\2\0"+
    "\1\10\5\0\23\10\1\156\7\10\4\0\3\10\2\0"+
    "\1\10\5\0\11\10\1\157\21\10\4\0\3\10\2\0"+
    "\1\10\5\0\5\10\1\160\14\10\1\161\10\10\4\0"+
    "\3\10\2\0\1\10\5\0\11\10\1\162\21\10\4\0"+
    "\3\10\2\0\1\10\5\0\13\10\1\163\17\10\4\0"+
    "\3\10\2\0\1\10\5\0\4\10\1\164\26\10\4\0"+
    "\3\10\2\0\1\10\5\0\30\10\1\165\2\10\4\0"+
    "\2\10\1\166\2\0\1\10\5\0\11\10\1\167\21\10"+
    "\4\0\3\10\2\0\1\10\5\0\1\10\1\170\31\10"+
    "\4\0\3\10\2\0\1\10\5\0\13\10\1\171\5\10"+
    "\1\172\11\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\173\26\10\1\0\7\126\1\174\42\126\11\51\1\4"+
    "\1\127\37\51\3\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\175\26\10\4\0\3\10\2\0\1\10\5\0\1\10"+
    "\1\176\31\10\4\0\3\10\2\0\1\10\5\0\3\10"+
    "\1\177\27\10\4\0\3\10\2\0\1\10\5\0\11\10"+
    "\1\200\21\10\4\0\3\10\2\0\1\10\5\0\5\10"+
    "\1\201\25\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\202\26\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\203\26\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\204\26\10\4\0\3\10\2\0\1\10\5\0\25\10"+
    "\1\205\5\10\4\0\3\10\2\0\1\10\5\0\3\10"+
    "\1\206\27\10\4\0\3\10\2\0\1\10\5\0\2\10"+
    "\1\207\30\10\4\0\3\10\2\0\1\10\5\0\26\10"+
    "\1\210\4\10\4\0\3\10\2\0\1\10\5\0\3\10"+
    "\1\211\27\10\4\0\3\10\2\0\1\10\5\0\21\10"+
    "\1\212\11\10\4\0\3\10\2\0\1\10\5\0\13\10"+
    "\1\213\17\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\214\26\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\215\26\10\4\0\3\10\2\0\1\10\5\0\13\10"+
    "\1\216\17\10\4\0\3\10\2\0\1\10\5\0\5\10"+
    "\1\217\25\10\4\0\3\10\2\0\1\10\5\0\5\10"+
    "\1\220\13\10\1\221\11\10\4\0\3\10\2\0\1\10"+
    "\5\0\1\10\1\222\31\10\4\0\3\10\2\0\1\10"+
    "\5\0\15\10\1\223\15\10\4\0\3\10\2\0\1\10"+
    "\5\0\5\10\1\224\25\10\4\0\3\10\2\0\1\10"+
    "\5\0\22\10\1\225\10\10\4\0\3\10\2\0\1\10"+
    "\5\0\4\10\1\226\26\10\4\0\3\10\2\0\1\10"+
    "\5\0\20\10\1\227\12\10\4\0\3\10\2\0\1\10"+
    "\5\0\20\10\1\230\12\10\4\0\3\10\2\0\1\10"+
    "\5\0\31\10\1\231\1\10\4\0\3\10\2\0\1\10"+
    "\5\0\16\10\1\232\14\10\4\0\3\10\2\0\1\10"+
    "\5\0\11\10\1\233\21\10\4\0\3\10\2\0\1\10"+
    "\5\0\5\10\1\234\25\10\1\0\7\126\1\235\42\126"+
    "\3\0\3\10\2\0\1\10\5\0\15\10\1\236\15\10"+
    "\4\0\3\10\2\0\1\10\5\0\3\10\1\237\27\10"+
    "\4\0\3\10\2\0\1\10\5\0\22\10\1\240\10\10"+
    "\4\0\3\10\2\0\1\10\5\0\4\10\1\241\26\10"+
    "\4\0\3\10\2\0\1\10\5\0\22\10\1\242\10\10"+
    "\4\0\3\10\2\0\1\10\5\0\12\10\1\243\20\10"+
    "\4\0\3\10\2\0\1\10\5\0\4\10\1\244\26\10"+
    "\4\0\3\10";

   private val ZZ_TRANS_PACKED_2:String = 
    "\2\0\1\10\5\0\5\10\1\245\25\10\4\0\3\10"+
    "\2\0\1\10\5\0\21\10\1\246\11\10\4\0\3\10"+
    "\2\0\1\10\5\0\17\10\1\247\13\10\4\0\3\10"+
    "\2\0\1\10\5\0\11\10\1\250\21\10\4\0\3\10"+
    "\2\0\1\10\5\0\16\10\1\251\14\10\4\0\3\10"+
    "\2\0\1\10\5\0\13\10\1\252\17\10\4\0\3\10"+
    "\2\0\1\10\5\0\22\10\1\253\10\10\4\0\3\10"+
    "\2\0\1\10\5\0\15\10\1\254\15\10\4\0\3\10"+
    "\2\0\1\10\5\0\4\10\1\255\26\10\4\0\3\10"+
    "\2\0\1\10\5\0\22\10\1\256\10\10\4\0\3\10"+
    "\2\0\1\10\5\0\1\10\1\257\31\10\4\0\3\10"+
    "\2\0\1\10\5\0\13\10\1\260\17\10\4\0\3\10"+
    "\2\0\1\10\5\0\22\10\1\261\10\10\4\0\3\10"+
    "\2\0\1\10\5\0\2\10\1\262\30\10\4\0\3\10"+
    "\2\0\1\10\5\0\2\10\1\263\30\10\4\0\3\10"+
    "\2\0\1\10\5\0\4\10\1\264\26\10\4\0\3\10"+
    "\2\0\1\10\5\0\6\10\1\265\24\10\1\0\7\126"+
    "\1\266\42\126\3\0\3\10\2\0\1\10\5\0\2\10"+
    "\1\267\30\10\4\0\3\10\2\0\1\10\5\0\6\10"+
    "\1\270\24\10\4\0\3\10\2\0\1\10\5\0\6\10"+
    "\1\271\24\10\4\0\3\10\2\0\1\10\5\0\5\10"+
    "\1\272\25\10\4\0\3\10\2\0\1\10\5\0\14\10"+
    "\1\273\16\10\4\0\3\10\2\0\1\10\5\0\4\10"+
    "\1\274\26\10\4\0\3\10\2\0\1\10\5\0\1\10"+
    "\1\275\31\10\4\0\3\10\2\0\1\10\5\0\11\10"+
    "\1\276\21\10\4\0\3\10\2\0\1\10\5\0\13\10"+
    "\1\277\17\10\4\0\3\10\2\0\1\10\5\0\11\10"+
    "\1\300\21\10\4\0\3\10\2\0\1\10\5\0\22\10"+
    "\1\301\10\10\4\0\3\10\2\0\1\10\5\0\12\10"+
    "\1\302\20\10\4\0\3\10\2\0\1\10\5\0\32\10"+
    "\1\303\4\0\3\10\2\0\1\10\5\0\11\10\1\304"+
    "\21\10\4\0\3\10\2\0\1\10\5\0\1\10\1\305"+
    "\31\10\4\0\3\10\2\0\1\10\5\0\1\10\1\306"+
    "\31\10\4\0\3\10\2\0\1\10\5\0\3\10\1\307"+
    "\27\10\4\0\3\10\2\0\1\10\5\0\25\10\1\310"+
    "\5\10\4\0\3\10\2\0\1\10\5\0\4\10\1\311"+
    "\26\10\4\0\3\10\2\0\1\10\5\0\13\10\1\312"+
    "\17\10\4\0\3\10\2\0\1\10\5\0\6\10\1\313"+
    "\24\10\4\0\3\10\2\0\1\10\5\0\4\10\1\314"+
    "\26\10\4\0\3\10\2\0\1\10\5\0\4\10\1\315"+
    "\26\10\4\0\3\10\2\0\1\10\5\0\4\10\1\316"+
    "\26\10\4\0\3\10\2\0\1\10\5\0\11\10\1\317"+
    "\21\10\4\0\3\10\2\0\1\10\5\0\11\10\1\320"+
    "\21\10\4\0\3\10\2\0\1\10\5\0\11\10\1\321"+
    "\21\10\4\0\3\10\2\0\1\10\5\0\4\10\1\322"+
    "\26\10\4\0\3\10\2\0\1\10\5\0\3\10\1\323"+
    "\27\10\4\0\3\10\2\0\1\10\5\0\4\10\1\324"+
    "\26\10\4\0\3\10\2\0\1\10\5\0\6\10\1\325"+
    "\24\10\1\0";

  private def zzUnpackTrans() : Array[Int] =  {
    val result:Array[Int] = new Array[Int](6552);
    var offset:Int = 0;
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_1, offset, result);
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_2, offset, result);
    return result;
  }

  private def zzUnpackTrans(packed:String,offset:Int,result:Array[Int]) : Int =  {
    var i:Int = 0;       /* index in packed string  */
    var j:Int = offset;  /* index in unpacked array */
    val l:Int = packed.length();
    while (i < l) {
      var count:Int = packed.charAt(i); i+= 1;
      var value:Int = packed.charAt(i); i+= 1;
      value-= 1;
      do { result(j) = value; j+=1; count -= 1; } while (count > 0);
    }
    return j;
  }
   private val ZZ_TRANS:Array[Int] = zzUnpackTrans();


  /* error codes */
  private val ZZ_UNKNOWN_ERROR : Int = 0;
  private val ZZ_NO_MATCH : Int = 1;
  private val ZZ_PUSHBACK_2BIG : Int = 2;

  /* error messages for the codes above */
  private val ZZ_ERROR_MSG: Array[String] = Array(
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  );

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */

   private val ZZ_ATTRIBUTE_PACKED_0:String = 
    "\2\0\1\1\1\11\4\1\1\11\30\1\2\11\3\1"+
    "\1\0\2\1\3\11\40\1\11\11\140\1\1\11\37\1";

  private def zzUnpackAttribute() : Array[Int] =  {
    val result:Array[Int] = new Array[Int](213);
    var offset:Int = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private def zzUnpackAttribute(packed:String,offset:Int,result:Array[Int]) : Int =  {
    var i:Int = 0;       /* index in packed string  */
    var j:Int = offset;  /* index in unpacked array */
    val l:Int = packed.length();
    while (i < l) {
      var count:Int = packed.charAt(i); i+= 1;
      var value:Int = packed.charAt(i); i+= 1;
      do { result(j) = value; j+=1; count -= 1; } while (count > 0);
    }
    return j;
  }
   private val ZZ_ATTRIBUTE:Array[Int] = zzUnpackAttribute();


  /** the current state of the DFA */
  private var zzState : Int = 0;

  /** the current lexical state */
  private var zzLexicalState : Int = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private var zzBuffer : Array[Char] = new Array(ZZ_BUFFERSIZE);

  /** the textposition at the last accepting state */
  private var zzMarkedPos : Int = 0;

  /** the current text position in the buffer */
  private var zzCurrentPos : Int = 0;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private var zzStartRead : Int = 0;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private var zzEndRead : Int = 0;

  /** number of newlines encountered up to the start of the matched text */
  private var yyline : Int = 0;

  /** the number of characters up to the start of the matched text */
  private var yychar : Int = 0;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private var yycolumn : Int = 0;

  /** 
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  private var zzAtBOL : Boolean = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private var zzAtEOF : Boolean = false;

  /* user code: */
  // These features are added to the Scanner class

  // ## The following comment is for students:
  // This constant is useful (but not directly) for limiting literal ints
  var maxint_string = "2147483647";
  // #(
  def int_string_ok(s : String) : Boolean = 
    if (s.length() < maxint_string.length()) true
    else if (maxint_string.length() < s.length()) false
    else (maxint_string.compareTo(s) >= 0);
  // #)
  // ## The following comment is for students:
  // You will find this attribute useful for building up strings.
  // See StringBuffer.cool
  var string_error : String = null;
  var string : StringBuffer = new StringBuffer();
  def symbol(n : String) : Symbol = Symbol(n);

  var in_basic_file : Boolean = false;
  def set_in_basic_file(v : Boolean) : Unit = in_basic_file = v;
  
  var io : IO = new IO();
  var lookahead : CoolTokens.YYToken = null;
   
  override def hasNext() : Boolean = { 
    if (io.is_null(lookahead)) lookahead = yylex();
    lookahead match {
      case x:CoolTokens.YYEOF => false;
      case x:CoolTokens.YYToken => true;
    }
  };
  
  override def next() : CoolTokens.YYToken = {
    if (io.is_null(lookahead)) lookahead = yylex();
    var result : CoolTokens.YYToken = lookahead;
    lookahead = null;
    result
  };
  
  def getLineNumber() : Int = yyline+1;



  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */

  /** 
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return         the unpacked character translation table
   */
  private def zzUnpackCMap(packed:String) : Array[Char] = {
    val map:Array[Char] = new Array[Char](0x10000);
    var i:Int = 0;  /* index in packed string  */
    var j:Int = 0;  /* index in unpacked array */
    while (i < 118) {
      var count:Int = packed.charAt(i); i+= 1;
      var value:Char = packed.charAt(i); i+= 1;
      do { map(j) = value; j+=1; count-=1; } while (count > 0);
    }
    return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   */
  private def zzRefill() : Boolean = {

    /* first: make room (if you can) */
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

      /* translate stored positions */
      zzEndRead-= zzStartRead;
      zzCurrentPos-= zzStartRead;
      zzMarkedPos-= zzStartRead;
      zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (zzCurrentPos >= zzBuffer.length) {
      /* if not: blow it up */
      val newBuffer : Array[Char] = new Array(zzCurrentPos*2);
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    val numRead : Int = zzReader.read(zzBuffer, zzEndRead,
                                      zzBuffer.length-zzEndRead);

    if (numRead > 0) {
      zzEndRead+= numRead;
      return false;
    }
    // unlikely but not impossible: read 0 characters, but not at end of stream    
    if (numRead == 0) {
      val c : Int = zzReader.read();
      if (c == -1) {
        return true;
      } else {
        zzBuffer(zzEndRead) = c toChar;
	    zzEndRead += 1
        return false;
      }     
    }

	// numRead < 0
    return true;
  }

    
  /**
   * Closes the input stream.
   */
  def yyclose() : Unit = {
    zzAtEOF = true;            /* indicate end of file */
    zzEndRead = zzStartRead;  /* invalidate buffer    */

    if (zzReader != null)
      zzReader.close();
  }


  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   */
  def yyreset(reader : java.io.Reader) : Unit = {
    zzReader = reader;
    zzAtBOL  = true;
    zzAtEOF  = false;
    zzEndRead = 0; zzStartRead = 0;
    zzCurrentPos = 0; zzMarkedPos = 0;
    yyline = 0; yychar = 0; yycolumn = 0;
    zzLexicalState = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  def yystate() : Int = {
    zzLexicalState;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  def yybegin(newState : Int) : Unit = {
    zzLexicalState = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  def yytext() : String = {
    new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  def yycharat(pos : Int) : Char = {
    zzBuffer(zzStartRead+pos);
  }


  /**
   * Returns the length of the matched text region.
   */
  def yylength() : Int = {
    zzMarkedPos-zzStartRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private def zzScanError(errorCode:Int) : Unit =  {
    var message : String = null;
    try {
      message = ZZ_ERROR_MSG(errorCode);
    } catch {
      case e:ArrayIndexOutOfBoundsException =>
	    message = ZZ_ERROR_MSG(ZZ_UNKNOWN_ERROR);
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  def yypushback(number:Int) : Unit =  {
    if ( number > yylength() )
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }

  /** Nested class to simulate multi-level break */
  private case class ZZbreak(name:String) extends Throwable;

  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  def yylex() : CoolTokens.YYToken = 
 {
    var zzInput : Int = 0;
    var zzAction : Int = 0;

    // cached fields:
    var zzCurrentPosL : Int = 0;
    var zzMarkedPosL : Int = 0;
    var zzEndReadL : Int = zzEndRead;
    var zzBufferL : Array[Char] = zzBuffer;
    var zzCMapL : Array[Char] = ZZ_CMAP;

    val zzTransL:Array[Int] = ZZ_TRANS;
    val zzRowMapL:Array[Int] = ZZ_ROWMAP;
    val zzAttrL:Array[Int] = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      var zzR:Boolean = false;
      zzCurrentPosL = zzStartRead
      while (zzCurrentPosL < zzMarkedPosL) {
        (zzBufferL(zzCurrentPosL)) match {
        case '\u000B'
        |'\u000C'
        |'\u0085'
        |'\u2028'
        |'\u2029' => {
          yyline+=1;
          zzR = false;
          }
        case '\r' => {
          yyline+=1;
          zzR = true;
          }
        case '\n' => {
          if (zzR)
            zzR = false;
          else {
            yyline+=1;
          }
          }
        case _ => {
          zzR = false;
          }
        }
        zzCurrentPosL += 1;
      }

      if (zzR) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        var zzPeek:Boolean = false;
        if (zzMarkedPosL < zzEndReadL)
          zzPeek = zzBufferL(zzMarkedPosL) == '\n';
        else if (zzAtEOF)
          zzPeek = false;
        else {
          val eof:Boolean = zzRefill();
          zzEndReadL = zzEndRead;
          zzMarkedPosL = zzMarkedPos;
          zzBufferL = zzBuffer;
          if (eof) 
            zzPeek = false;
          else 
            zzPeek = zzBufferL(zzMarkedPosL) == '\n';
        }
        if (zzPeek) yyline-= 1;
      }
      zzAction = -1;

      { val p : Int = zzMarkedPosL;
        zzCurrentPosL = p; zzCurrentPos = p; zzStartRead = p;
      }
  
      zzState = ZZ_LEXSTATE(zzLexicalState);

      // set up zzAction for empty match case:
      var zzAttributes:Int = zzAttrL(zzState);
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      /* zzForAction: */ try {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL) {
            zzInput = zzBufferL(zzCurrentPosL);
            zzCurrentPosL += 1;
          } else if (zzAtEOF) {
            zzInput = YYEOF;
            throw ZZbreak("zzForAction");
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            val eof:Boolean = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              throw ZZbreak("zzForAction");
            }
            else {
              zzInput = zzBufferL(zzCurrentPosL);
              zzCurrentPosL += 1;
            }
          }
          val zzNext:Int = zzTransL(zzRowMapL(zzState) + zzCMapL(zzInput));
          if (zzNext == -1) throw ZZbreak("zzForAction");
          zzState = zzNext;

          zzAttributes = zzAttrL(zzState);
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) throw ZZbreak("zzForAction");
          }

        }
      } catch { case ZZbreak("zzForAction") => () }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      (if ( zzAction < 0 ) zzAction; else ZZ_ACTION(zzAction)) match  {
        case 2 => {
          { 
          }
          }
        case 71 => {}
        case 46 => {
          { return CoolTokens.CLASS();
          }
          }
        case 72 => {}
        case 19 => {
          { return CoolTokens.ERROR("Illegal keyword 'do'");
          }
          }
        case 73 => {}
        case 7 => {
          { var result : String = yytext();
                  if (int_string_ok(result)) 
		     return CoolTokens.INT_LIT(Symbol(result))
                  else return CoolTokens.ERROR("Integer literal too big: " + 
                                               result);
          }
          }
        case 74 => {}
        case 14 => {
          { return CoolTokens.ERROR("unterminated comment");
          }
          }
        case 75 => {}
        case 60 => {
          { return CoolTokens.ERROR("Illegal keyword 'return'");
          }
          }
        case 76 => {}
        case 41 => {
          { return CoolTokens.BOOL_LIT(true);
          }
          }
        case 77 => {}
        case 25 => {
          { string.append( "\t" );
          }
          }
        case 78 => {}
        case 39 => {
          { return CoolTokens.ERROR("Illegal keyword 'lazy'");
          }
          }
        case 79 => {}
        case 12 => {
          { yybegin(YYINITIAL); 
                  return CoolTokens.ERROR("Backslash at end of file");
          }
          }
        case 80 => {}
        case 37 => {
          { return CoolTokens.CASE();
          }
          }
        case 81 => {}
        case 68 => {
          { return CoolTokens.OVERRIDE();
          }
          }
        case 82 => {}
        case 6 => {
          { yybegin(STRING); string_error = ""; string.setLength(0);
          }
          }
        case 83 => {}
        case 49 => {
          { return CoolTokens.ERROR("Illegal keyword 'final'");
          }
          }
        case 84 => {}
        case 28 => {
          { string.append( "\b" );
          }
          }
        case 85 => {}
        case 34 => {
          { return CoolTokens.NEW();
          }
          }
        case 86 => {}
        case 3 => {
          { return CoolTokens.TYPEID(Symbol(yytext()));
          }
          }
        case 87 => {}
        case 13 => {
          { return CoolTokens.ERROR("An identifier may not start with an underscore: ".concat(yytext()));
		  /* return CoolTokens.OBJECTID(Symbol(yytext()));*/
          }
          }
        case 88 => {}
        case 32 => {
          { return CoolTokens.ERROR("Illegal keyword 'for'");
          }
          }
        case 89 => {}
        case 56 => {
          { return CoolTokens.ERROR("Illegal keyword 'sealed'");
          }
          }
        case 90 => {}
        case 58 => {
          { return CoolTokens.ERROR("Illegal keyword 'import'");
          }
          }
        case 91 => {}
        case 45 => {
          { return CoolTokens.ERROR("Illegal keyword 'catch'");
          }
          }
        case 92 => {}
        case 53 => {
          { return CoolTokens.WHILE();
          }
          }
        case 93 => {}
        case 17 => {
          { return CoolTokens.ARROW();
          }
          }
        case 94 => {}
        case 27 => {
          { string.append( "\r" );
          }
          }
        case 95 => {}
        case 70 => {
          { return CoolTokens.ERROR("Illegal keyword 'protected'");
          }
          }
        case 96 => {}
        case 18 => {
          { return CoolTokens.ERROR("Octal literal not supported: " + 
				          yytext());
          }
          }
        case 97 => {}
        case 61 => {
          { return CoolTokens.EXTENDS();
          }
          }
        case 98 => {}
        case 1 => {
          { return CoolTokens.ERROR("Illegal characters found on input: ".concat(yytext()));
          }
          }
        case 99 => {}
        case 15 => {
          { return CoolTokens.LE();
          }
          }
        case 100 => {}
        case 21 => {
          { string_error = "Illegal backslash escape: ".concat(yytext());
          }
          }
        case 101 => {}
        case 8 => {
          { return CoolTokens.INT_LIT(Symbol(yytext()));
          }
          }
        case 102 => {}
        case 62 => {
          { return CoolTokens.ERROR("Illegal keyword 'finally'");
          }
          }
        case 103 => {}
        case 67 => {
          { return CoolTokens.ERROR("Illegal keyword 'implicit'");
          }
          }
        case 104 => {}
        case 10 => {
          { yybegin(YYINITIAL); 
                  return CoolTokens.ERROR("Unterminated string at end of line");
          }
          }
        case 105 => {}
        case 4 => {
          { return CoolTokens.OBJECTID(Symbol(yytext()));
          }
          }
        case 106 => {}
        case 16 => {
          { return CoolTokens.EQEQ();
          }
          }
        case 107 => {}
        case 50 => {
          { return CoolTokens.ERROR("Illegal keyword 'throw'");
          }
          }
        case 108 => {}
        case 54 => {
          { return CoolTokens.ERROR("Illegal keyword 'yield'");
          }
          }
        case 109 => {}
        case 36 => {
          { return CoolTokens.VAR();
          }
          }
        case 110 => {}
        case 29 => {
          { string.append( "\\" );
          }
          }
        case 111 => {}
        case 42 => {
          { return CoolTokens.ERROR("Illegal keyword 'type'");
          }
          }
        case 112 => {}
        case 26 => {
          { string.append( "\n" );
          }
          }
        case 113 => {}
        case 40 => {
          { return CoolTokens.THIS();
          }
          }
        case 114 => {}
        case 5 => {
          { return CoolTokens.YYCHAR(yytext.charAt(0));
          }
          }
        case 115 => {}
        case 35 => {
          { return CoolTokens.ERROR("Illegal keyword 'val'");
          }
          }
        case 116 => {}
        case 65 => {
          { return CoolTokens.ERROR("Illegal keyword 'private'");
          }
          }
        case 117 => {}
        case 11 => {
          { yybegin(YYINITIAL); 
                  if (string_error == "")
                    return CoolTokens.STR_LIT(symbol(string.toString()))
		  else return CoolTokens.ERROR(string_error)
          }
          }
        case 118 => {}
        case 59 => {
          { return CoolTokens.ERROR("Illegal keyword 'object'");
          }
          }
        case 119 => {}
        case 23 => {
          { string.append( "\"" );
          }
          }
        case 120 => {}
        case 24 => {
          { string.append( "\f" );
          }
          }
        case 121 => {}
        case 20 => {
          { return CoolTokens.IF();
          }
          }
        case 122 => {}
        case 64 => {
          { return CoolTokens.ERROR("Illegal keyword 'package'");
          }
          }
        case 123 => {}
        case 47 => {
          { return CoolTokens.SUPER();
          }
          }
        case 124 => {}
        case 48 => {
          { return CoolTokens.BOOL_LIT(false);
          }
          }
        case 125 => {}
        case 22 => {
          { string_error = "Newlines cannot be escaped"
          }
          }
        case 126 => {}
        case 33 => {
          { return CoolTokens.ERROR("Illegal keyword 'try'");
          }
          }
        case 127 => {}
        case 44 => {
          { return CoolTokens.ERROR("Illegal keyword 'with'");
          }
          }
        case 128 => {}
        case 63 => {
          { return CoolTokens.ERROR("Illegal keyword 'forSome'");
          }
          }
        case 129 => {}
        case 57 => {
          { if (!in_basic_file) {
                     return CoolTokens.ERROR("Keyword 'native' may only be used in basic classes");
                  }
                  return CoolTokens.NATIVE();
          }
          }
        case 130 => {}
        case 55 => {
          { var n : Int = yytext.length();
	return CoolTokens.STR_LIT(symbol(yytext.substring(3,n-3)));
          }
          }
        case 131 => {}
        case 66 => {
          { return CoolTokens.ERROR("Illegal keyword 'abstract'");
          }
          }
        case 132 => {}
        case 38 => {
          { return CoolTokens.ELSE();
          }
          }
        case 133 => {}
        case 9 => {
          { string.append(yytext());
          }
          }
        case 134 => {}
        case 51 => {
          { return CoolTokens.ERROR("Illegal keyword 'trait'");
          }
          }
        case 135 => {}
        case 69 => {
          { return CoolTokens.ERROR("Illegal keyword 'requires'");
          }
          }
        case 136 => {}
        case 31 => {
          { return CoolTokens.DEF();
          }
          }
        case 137 => {}
        case 52 => {
          { return CoolTokens.MATCH();
          }
          }
        case 138 => {}
        case 30 => {
          { return CoolTokens.ERROR("Unterminated long string literal");
          }
          }
        case 139 => {}
        case 43 => {
          { return CoolTokens.NULL();
          }
          }
        case 140 => {}
        case _ =>
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            (zzLexicalState) match  {
            case YYINITIAL => { {
              return CoolTokens.YYEOF();
            }
            }
            case 214 => {}
            case STRING => { {
              yybegin(YYINITIAL); 
                  return CoolTokens.ERROR("Unterminated string at end of file");
            }
            }
            case 215 => {}
            case _ => {
            return null;
              }
            }
          } else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
    throw new RuntimeException("NOT REACHED");
  }


}
